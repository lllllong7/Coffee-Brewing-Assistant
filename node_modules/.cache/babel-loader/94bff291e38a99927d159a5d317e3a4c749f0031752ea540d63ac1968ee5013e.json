{"ast":null,"code":"// AI suggestion engine with OpenAI integration and fallback rules\n\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n// Fallback rules when AI is not available\nconst getFallbackSuggestion = (history, coffeeType) => {\n  const defaultSuggestions = {\n    espresso: {\n      grindSize: 2,\n      ratio: '1:2',\n      brewTime: 25,\n      explanation: 'Standard espresso parameters for balanced extraction.'\n    },\n    americano: {\n      grindSize: 3,\n      ratio: '1:15',\n      brewTime: 240,\n      explanation: 'Medium grind with longer extraction for full body.'\n    },\n    latte: {\n      grindSize: 2,\n      ratio: '1:2',\n      brewTime: 25,\n      explanation: 'Espresso base with milk - focused on strong coffee flavor.'\n    },\n    pourover: {\n      grindSize: 4,\n      ratio: '1:16',\n      brewTime: 300,\n      explanation: 'Medium-coarse grind for clean, bright extraction.'\n    }\n  };\n  if (!history || history.length === 0) {\n    return defaultSuggestions[coffeeType] || defaultSuggestions.espresso;\n  }\n  const lastBrew = history[0];\n  const {\n    grindSize,\n    ratio,\n    brewTime,\n    taste\n  } = lastBrew;\n  let newGrindSize = grindSize;\n  let newRatio = ratio;\n  let newBrewTime = brewTime;\n  let explanation = '';\n  switch (taste) {\n    case 'too_bitter':\n      newGrindSize = Math.min(grindSize + 0.5, 6);\n      newBrewTime = Math.max(brewTime - 10, 15);\n      explanation = 'Making grind coarser and reducing time to reduce bitterness.';\n      break;\n    case 'too_sour':\n      newGrindSize = Math.max(grindSize - 0.5, 1);\n      newBrewTime = Math.min(brewTime + 15, 360);\n      explanation = 'Making grind finer and increasing time to improve extraction.';\n      break;\n    case 'balanced':\n      // Small optimizations for balanced brews\n      newGrindSize = grindSize + (Math.random() - 0.5) * 0.2;\n      explanation = 'Fine-tuning parameters to maintain balance with slight optimization.';\n      break;\n    default:\n      explanation = 'Using previous parameters as baseline for next brew.';\n  }\n  return {\n    grindSize: Math.round(newGrindSize * 10) / 10,\n    ratio: newRatio,\n    brewTime: Math.round(newBrewTime),\n    explanation\n  };\n};\n\n// OpenAI API call\nconst getAISuggestion = async (history, coffeeType) => {\n  if (!OPENAI_API_KEY) {\n    throw new Error('OpenAI API key not configured');\n  }\n  const prompt = `Based on the user's previous brews: ${JSON.stringify(history)}, and their target coffee type: ${coffeeType}, recommend the next brew's grind size (numeric 1-6 scale), coffee-to-water ratio (e.g. 1:15), and brew time (seconds). Also explain briefly why these adjustments are being made in simple language. Return JSON with keys: grindSize, ratio, brewTime, explanation.`;\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-3.5-turbo',\n        messages: [{\n          role: 'system',\n          content: 'You are a coffee brewing expert. Provide precise brewing recommendations based on taste feedback and brewing history.'\n        }, {\n          role: 'user',\n          content: prompt\n        }],\n        max_tokens: 200,\n        temperature: 0.3\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`OpenAI API error: ${response.status}`);\n    }\n    const data = await response.json();\n    const suggestion = JSON.parse(data.choices[0].message.content);\n\n    // Validate the response structure\n    if (!suggestion.grindSize || !suggestion.ratio || !suggestion.brewTime || !suggestion.explanation) {\n      throw new Error('Invalid AI response format');\n    }\n    return suggestion;\n  } catch (error) {\n    console.error('AI suggestion error:', error);\n    throw error;\n  }\n};\n\n// Main suggestion function\nexport const getSuggestion = async (history, coffeeType = 'espresso') => {\n  try {\n    // Try AI first if API key is available\n    if (OPENAI_API_KEY) {\n      return await getAISuggestion(history, coffeeType);\n    }\n  } catch (error) {\n    console.warn('AI suggestion failed, using fallback:', error.message);\n  }\n\n  // Use fallback rules\n  return getFallbackSuggestion(history, coffeeType);\n};\nexport const COFFEE_TYPES = ['espresso', 'americano', 'latte', 'cappuccino', 'pourover', 'french_press', 'aeropress'];\nexport const TASTE_OPTIONS = [{\n  value: 'too_bitter',\n  label: 'Too Bitter'\n}, {\n  value: 'too_sour',\n  label: 'Too Sour'\n}, {\n  value: 'balanced',\n  label: 'Balanced'\n}, {\n  value: 'weak',\n  label: 'Too Weak'\n}, {\n  value: 'strong',\n  label: 'Too Strong'\n}];","map":{"version":3,"names":["OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","getFallbackSuggestion","history","coffeeType","defaultSuggestions","espresso","grindSize","ratio","brewTime","explanation","americano","latte","pourover","length","lastBrew","taste","newGrindSize","newRatio","newBrewTime","Math","min","max","random","round","getAISuggestion","Error","prompt","JSON","stringify","response","fetch","method","headers","body","model","messages","role","content","max_tokens","temperature","ok","status","data","json","suggestion","parse","choices","message","error","console","getSuggestion","warn","COFFEE_TYPES","TASTE_OPTIONS","value","label"],"sources":["/Users/wanglinlong/CascadeProjects/coffee-brewing-assistant/src/services/aiSuggestions.js"],"sourcesContent":["// AI suggestion engine with OpenAI integration and fallback rules\n\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY;\n\n// Fallback rules when AI is not available\nconst getFallbackSuggestion = (history, coffeeType) => {\n  const defaultSuggestions = {\n    espresso: { grindSize: 2, ratio: '1:2', brewTime: 25, explanation: 'Standard espresso parameters for balanced extraction.' },\n    americano: { grindSize: 3, ratio: '1:15', brewTime: 240, explanation: 'Medium grind with longer extraction for full body.' },\n    latte: { grindSize: 2, ratio: '1:2', brewTime: 25, explanation: 'Espresso base with milk - focused on strong coffee flavor.' },\n    pourover: { grindSize: 4, ratio: '1:16', brewTime: 300, explanation: 'Medium-coarse grind for clean, bright extraction.' }\n  };\n\n  if (!history || history.length === 0) {\n    return defaultSuggestions[coffeeType] || defaultSuggestions.espresso;\n  }\n\n  const lastBrew = history[0];\n  const { grindSize, ratio, brewTime, taste } = lastBrew;\n  \n  let newGrindSize = grindSize;\n  let newRatio = ratio;\n  let newBrewTime = brewTime;\n  let explanation = '';\n\n  switch (taste) {\n    case 'too_bitter':\n      newGrindSize = Math.min(grindSize + 0.5, 6);\n      newBrewTime = Math.max(brewTime - 10, 15);\n      explanation = 'Making grind coarser and reducing time to reduce bitterness.';\n      break;\n    case 'too_sour':\n      newGrindSize = Math.max(grindSize - 0.5, 1);\n      newBrewTime = Math.min(brewTime + 15, 360);\n      explanation = 'Making grind finer and increasing time to improve extraction.';\n      break;\n    case 'balanced':\n      // Small optimizations for balanced brews\n      newGrindSize = grindSize + (Math.random() - 0.5) * 0.2;\n      explanation = 'Fine-tuning parameters to maintain balance with slight optimization.';\n      break;\n    default:\n      explanation = 'Using previous parameters as baseline for next brew.';\n  }\n\n  return {\n    grindSize: Math.round(newGrindSize * 10) / 10,\n    ratio: newRatio,\n    brewTime: Math.round(newBrewTime),\n    explanation\n  };\n};\n\n// OpenAI API call\nconst getAISuggestion = async (history, coffeeType) => {\n  if (!OPENAI_API_KEY) {\n    throw new Error('OpenAI API key not configured');\n  }\n\n  const prompt = `Based on the user's previous brews: ${JSON.stringify(history)}, and their target coffee type: ${coffeeType}, recommend the next brew's grind size (numeric 1-6 scale), coffee-to-water ratio (e.g. 1:15), and brew time (seconds). Also explain briefly why these adjustments are being made in simple language. Return JSON with keys: grindSize, ratio, brewTime, explanation.`;\n\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-3.5-turbo',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are a coffee brewing expert. Provide precise brewing recommendations based on taste feedback and brewing history.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ],\n        max_tokens: 200,\n        temperature: 0.3\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`OpenAI API error: ${response.status}`);\n    }\n\n    const data = await response.json();\n    const suggestion = JSON.parse(data.choices[0].message.content);\n    \n    // Validate the response structure\n    if (!suggestion.grindSize || !suggestion.ratio || !suggestion.brewTime || !suggestion.explanation) {\n      throw new Error('Invalid AI response format');\n    }\n\n    return suggestion;\n  } catch (error) {\n    console.error('AI suggestion error:', error);\n    throw error;\n  }\n};\n\n// Main suggestion function\nexport const getSuggestion = async (history, coffeeType = 'espresso') => {\n  try {\n    // Try AI first if API key is available\n    if (OPENAI_API_KEY) {\n      return await getAISuggestion(history, coffeeType);\n    }\n  } catch (error) {\n    console.warn('AI suggestion failed, using fallback:', error.message);\n  }\n  \n  // Use fallback rules\n  return getFallbackSuggestion(history, coffeeType);\n};\n\nexport const COFFEE_TYPES = [\n  'espresso',\n  'americano',\n  'latte',\n  'cappuccino',\n  'pourover',\n  'french_press',\n  'aeropress'\n];\n\nexport const TASTE_OPTIONS = [\n  { value: 'too_bitter', label: 'Too Bitter' },\n  { value: 'too_sour', label: 'Too Sour' },\n  { value: 'balanced', label: 'Balanced' },\n  { value: 'weak', label: 'Too Weak' },\n  { value: 'strong', label: 'Too Strong' }\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}